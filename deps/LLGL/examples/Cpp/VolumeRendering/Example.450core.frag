// GLSL Fragment Shader "PScene"
// Generated by XShaderCompiler
// 19/08/2019 20:39:26

#version 450 core

layout(location = 0) in vec4 xsv_NDC0;
layout(location = 1) in vec4 xsv_WORLDPOS0;
layout(location = 2) in vec4 xsv_MODELPOS0;
layout(location = 3) in vec4 xsv_NORMAL0;

layout(location = 0) out vec4 SV_Target0;

//  HLSL model shader
layout(std140, row_major, binding = 1) uniform Settings
{
    mat4  wMatrix;
    mat4  wMatrixInv;
    mat4  vpMatrix;
    mat4  vpMatrixInv;
    vec3  lightDir;
    float shininess;
    vec3  viewPos;
    float threshold;
    
    // should be in open range (0, 0.5).
    vec3  albedo;
    float reflectance;
};

//  PIXEL SHADER SCENE
layout(binding = 2) uniform texture3D noiseTexture;

layout(binding = 3) uniform texture2D depthRangeTexture;

layout(binding = 4) uniform sampler linearSampler;

float SampleNoise(vec3 v)
{
    return float(texture(sampler3D(noiseTexture, linearSampler), v));
}

float SampleVolume(vec3 pos)
{
    float noise = SampleNoise(pos * 0.5);
    return smoothstep(0.5 - threshold, 0.5 + threshold, noise);
}

float SampleVolumeInBoundary(vec3 pos)
{
    return SampleVolume((vec4(pos, 1) * wMatrixInv).xyz);
}

float DiffuseShading(vec3 normal, vec3 lightVec)
{
    float NdotL = dot(normal, lightVec);
    return mix(0.2, 1.0, max(0.0, NdotL));
}

float SpecularShading(vec3 normal, vec3 lightVec, vec3 viewVec)
{
    vec3 halfVec = normalize(viewVec + lightVec);
    float NdotH = dot(normal, halfVec);
    return pow(max(0.0, NdotH), shininess);
}

float Glitter(vec3 normal, vec3 lightVec, vec3 viewVec, vec3 noisePos)
{
    float RdotL = dot(reflect(-viewVec, normal), lightVec);
    float specBase = mix(0.2, 1.0, clamp(RdotL, float(0), float(1)));
    vec3 fp = fract(noisePos * 150.0 + vec3(SampleNoise(noisePos * 12.0) * 9.0) + viewVec * 0.1);
    fp *= (vec3(1.0) - fp);
    float glitter = clamp(1.0 - 7.0 * (fp.x + fp.y + fp.z), float(0), float(1));
    return glitter * pow(specBase, 1.5);
}

void UnprojectDepth(inout vec4 v)
{
    v = (v * vpMatrixInv);
    v /= vec4(v.w);
}

void main()
{
    // Get input vectors
    vec3 normal = normalize(xsv_NORMAL0.xyz);
    vec3 lightVec = -lightDir.xyz;
    vec3 viewVec = normalize(viewPos.xyz - xsv_WORLDPOS0.xyz);
    
    // Compute blinn-phong shading
    float diffuse = DiffuseShading(normal, lightVec);
    float specular = SpecularShading(normal, lightVec, viewVec) * reflectance;
    
    #if 0
    // Sample noise texture and apply glitter
    specular += Glitter(normal, lightVec, viewVec, xsv_WORLDPOS0.xyz);
    #endif
    
    // Project depth back into scene
    vec2 screenPos = xsv_NDC0.xy;
    vec2 texCoord = screenPos * vec2(0.5, -0.5) + vec2(0.5);
    float maxDepth = float(texture(sampler2D(depthRangeTexture, linearSampler), texCoord));
    vec4 maxDepthPos = vec4(screenPos.x, screenPos.y, maxDepth, 1.0);
    UnprojectDepth(maxDepthPos);
    
    // Integrate volume density
    int numIterations = 64;
    float stride = 1.0 / float(numIterations);
    float trace = 0.0;
    float density = 0.0;
    float depthRange = distance(xsv_WORLDPOS0.xyz, maxDepthPos.xyz);
    float dt = depthRange * stride * 5.0;
    for (int i = 0; i < numIterations; ++i)
    {
        vec3 tracePos = mix(xsv_WORLDPOS0.xyz, maxDepthPos.xyz, vec3(trace));
        density += SampleVolumeInBoundary(tracePos) * dt;
        trace += stride;
    }
    
    // Apply density attenuation, i.e. rescale range [0, +inf) to [0, 1).
    density = 1.0 - exp(-density * 0.5);
    
    // Put everything together
    SV_Target0 = vec4(albedo.rgb * diffuse * mix(0.35, 1.5, density) + vec3(specular), 1.0);
}

